- Redux - это библиотека для управления состоянием приложения в JavaScript-приложениях. Она основана на концепции однонаправленного потока данных и является популярным инструментом в разработке веб-приложений.

- Основная идея Redux состоит в том, что вся информация о состоянии приложения хранится в единственном объекте, называемом "стор" (store). Состояние приложения в Redux является неизменяемым, что означает, что его нельзя изменить напрямую. Вместо этого любые изменения состояния осуществляются путем создания и отправки "действий" (actions) в редьюсеры (reducers).

- Действия представляют собой простые объекты, которые описывают, что произошло в приложении. Редьюсеры - это чистые функции, которые принимают текущее состояние и действие, и возвращают новое состояние. Каждый редьюсер отвечает за обновление определенной части состояния.

- Redux также включает в себя понятие "селекторов" (selectors), которые позволяют извлекать определенные данные из состояния. Селекторы полезны для получения нужной информации из сложной структуры состояния, избегая необходимости напрямую обращаться к нему.

- Для связи Redux со своим приложением используются "привязки" (bindings). Обычно это делается с помощью библиотеки react-redux, которая предоставляет инструменты для интеграции Redux с React-приложениями.

- Redux позволяет эффективно управлять состоянием приложения, облегчает отслеживание изменений и упрощает тестирование. Она широко используется в разработке веб-приложений на JavaScript и является одной из основных составляющих архитектуры Flux.

- Redux Toolkit - это пакет, облегчающий работу с Redux. Он был разработан для решения трех главных проблем:

- Слишком сложная настройка хранилища (store)
Для того, чтобы заставить Redux делать что-то полезное, приходится использовать дополнительные пакеты
- Слишком много шаблонного кода (boilerplate)
Redux Toolkit предоставляет инструменты для настройки хранилища и выполнения наиболее распространенных операций, а также содержит полезные утилиты, позволяющие упростить код.

- Redux Toolkit включает в себя следующие API:

1. configureStore(): обертка для createStore(), упрощающая настройку хранилища с настройками по умолчанию. Позволяет автоматически комбинировать отдельные частичные редукторы (slice reducers), добавлять промежуточные слои или посредников (middlewares), по умолчанию включает redux-thunk (преобразователя), позволяет использовать расширение Redux DevTools (инструменты разработчика Redux)

2. createReducer(): позволяет использовать таблицу поиска (lookup table) операций для редукторов случая (case reducers) вместо инструкций switch. В данном API используется библиотека immer, позволяющая напрямую изменять иммутабельный код, например, так: state.todos[3].completed = true

3. createAction(): генерирует создателя операции (action creator) для переданного типа операции. Функция имеет переопределенный метод toString(), что позволяет использовать ее вместо константы типа

4. createSlice(): принимает объект, содержащий редуктор, название части состояния (state slice), начальное значение состояния, и автоматически генерирует частичный редуктор с соответствующими создателями и типами операции

5. createAsyncThunk(): принимает тип операции и функцию, возвращающую промис, и генерирует thunk, отправляющий типы операции pending/fulfilled/rejected на основе промиса

6. createEntityAdapter(): генерирует набор переиспользуемых редукторов и селекторов для управления нормализованными данными в хранилище

7. утилита createSelector() из библиотеки Reselect

1. useRef() используется для получения ссылки на DOM-элемент. При клике на кнопку "Focus Input" фокус переключается на это поле ввода.

import React, { useRef } from 'react';

function TextInput() {
  const inputRef = useRef(null);

  const handleButtonClick = () => {
    // Фокус на input при клике на кнопку
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleButtonClick}>Focus Input</button>
    </div>
  );
}

2. useContext() - для доступа к контексту(мы решаем эту задачу через Redux):

import React, { useContext } from 'react';

const ThemeContext = React.createContext('light');

function ThemeConsumer() {
  const theme = useContext(ThemeContext);

  return <p>Current theme: {theme}</p>;
}

3. useEffect() - для выполнения побочных эффектов (например, для работы с жизненным циклом компонента):

import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Запрос к API
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => setData(data));
  }, []); // Пустой массив зависимостей - выполнится только после монтирования компонента

  return (
    <div>
      {data ? <p>Data: {data}</p> : <p>Loading...</p>}
    </div>
  );
}