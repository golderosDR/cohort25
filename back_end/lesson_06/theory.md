## 01. Статусы ошибок, которые могут быть в приложении 

* `400 Bad Request` - это когда вы отправили "плохой запрос", который не может обработаться сервером.
  * Например, он ожидает одного, а вы отправляете другое
* `405 Method not allowed` - это значит, что на сервере для данного запроса не поддерживается указанный метод
  * Например, у вас есть только обработчик `GET /users`, а вы отправляете `POST /users`
* `500 Internal Server Error` - ошибка на сервере, нужно смтореть логи вашего приложения
* `CORS Error` - возникает, если Frontend и Backend запущены на разных доменах. Сервер не разрешает запросы от сторонних для него источников.

## 02. DTO

* Data Transfer Object - объект для транспортировки данных
* Очень важный слой, который представляет собой класс, описывающий объект:
  * Который мы принимаем от клиента
  * Отправляем клиенту
* Его необходимость обусловлена тем, что на фронтэнде и бэкенде данные могут иметь разный вид
* По сути DTO - это те JSON, которые принимают и отдают фронтенду
* Также они помогают нам документировать API

## Почему MVC - это плохо?

* Разработка Frontend и Backend выполняется в одном проекте - это нарушает их независимость
  * Если мы хотим использовать какие-то сложные или крутые штуки, например `React` или `Angular`, то это будет достаточно сложно
* Некоторые Frontend-страницы (в частности, `ftlh`) содержат теги специфичного фреймворка, который нужно еще выучить
* Если появится другой тип клиентского приложения (например, мобильное приложение), то нам придется писать другие типы контроллеров
* Глобально, Frontend и Backend должны быть максимально независимыми
* Следует применять подход, который позволяет приложению просто принимать и отправлять данные, но не отвечать за их внешний вид

## Альтернативный подход

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_06/img/1.png)

* Реализовать backend как API (Application Programming Interface) - набор методов, который предоставляется backend-ом
* Тогда каждый тип клиента может отдавать/принимать JSON и отображать это так, как ему нужно
* Сервер при этом не думает о том, как это выглядит, а только манипулирует данными

```json
{
  "firstName": "Marsel",
  "lastName": "Sidikov",
  "email": "sidikov.marsel@gmail.com",
  "password": "qwerty007"
}
```

## Замечания

* Очень важно при получении запроса на сохранение сущности (например POST-запрос) в ответе вернуть эту же сущность.
* Тогда Frontend может иметь актуальную информацию о добавленной сущности (например, ее id, который присвоил backend). 

## Аннотации Spring

* `@ResponseBody` - обозначает, что метод возвращает не название страницы, а полноценный JSON-объект
* `@RequestBody` - обозначает, что метод принимает на вход не HTTP-форму, а полноценный JSON-объект

## Аннотации lombok

* ВАЖНО: проверьте `plugins` - плагины IDEA

* `@RequiredArgsConstructor` - автоматически создает конструктор для final-полей
* `@Getter` - автоматически создает геттеры на все поля
* `@Setter` - автоматически создает сеттеры на все поля
* `@AllArgsConstructor` - автоматически создает конструктор для всех полей
* `@NoArgsConstructor` - автоматически создает пустой конструктор

## Swagger

* Предназначен для документации вашего API
* Автоматически сканирует ваши контроллеры и генерирует сайт с документацией:
  * `http://localhost:8080/swagger-ui/index.html`
* Используя аннотации `@Tags`,`@Operation`,`@Schema` можно задокументировать контроллеры и DTO.

## Тезисы

* Переход от MVC-архитектуры к API - мы больше не возвращает страницы с бека, мы просто отправляем и принимаем JSON
  * Поскольку FRONTEND может быть на любом домене, необходимо разрешить на сервере обработку запросов с любого домена, в `ApiDemoApplication`:

```
 @Bean
    public WebMvcConfigurer cors() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**").allowedOrigins("*");
            }
        };
    }
```

* В контроллере мы оставили методы, которые используют аннотации `@RequestBody` и `@ResponseBody`
* Поскольку данные, которые мы принимаем от фронта или отдаем фронту могут отличаться от того, что мы храним на беке, необходимо реализовать DTO-слой
  * Каждый DTO специфичен для запроса (поэтому у нас есть `NewUserDto`, когда мы получаем и `UserDto`, когда отдаем)
  * Каждый исходящий DTO должен содержать методы для конвертации из одной модели и списка моделей
  * DTO-работают на уровне контроллеров и сервисов (т.е. методы сервисов должны принимать и отдавать DTO)
  * Поскольку методы конвертации статические, то их можно просто импортировать в сервис слой и вызывать только по названию:
    * `import static de.ait.shop.dto.UserDto.from;`
    * `return from(user);`
* Мы использовали аннотации lombok
* Запросы можно проверять через Intellij IDEA (для этого нужно создать requests.http-файл)
  * Важно, чтобы сервер был запущен
* Поскольку Frontend-у нужно понимать, какой запрос за что отвечает и какие вообще запросы есть, нам нужно сделать документацию.