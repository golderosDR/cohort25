# Lesson 02 - 23/08/2023 - архитектура консольного приложения

## Тестирование нашего проекта

* Если мы хотим протестировать слой, который отвечает за работу с данными (репозитории), то:
  * Не следует использовать для тестирования ту же базу данных (файл), которая используется в основном проекте
  * Вместо этого мы будем делать временный файл (временную базу данных) перед каждым тестом и будем сразу удалять его после каждого теста
  * Почему? Мы не хотим, чтобы тест повредил или как-либо изменил те данные, которые нам важны в основном проекте

* Если мы с вами хотим протестировать сервис, который зависит от другого репозитория, какую реализацию репозитория нам нужно подставить?\
  * Правильный подход - создать временную, фэйковую, заглушку, `mock`-реализацию для конкретного теста.
  * Для этой фэйковой реализации мы явно опишем какие значения должен возвращать тот или иной метод.
  * Такой подход называется mock-тестированием и используется в Unit/Модульных тестах.
  * Мы хотим проверить наш класс, независимо от того, как работают другие, чтобы точно понять причину ошибки.

* `@BeforeEach` - аннотация JUnit, которой мы можем пометить метод, запускаемый перед каждым тестом автоматически
* `@AfterEach` - аннотация JUnit, которой мы можем пометить метод, запускаемый после каждого теста
* `@Nested` - аннотация, которой можно помечать вложенные классы с тестами
  * Вложенные классы используем для группировки тестов, каждый вложенный класс может содержать тесты для конкретного метода

## Заметки

* `Arrays.asList(T ... a)` - создает `ArrayList` на основе набора объектов.
* `Mockito` - библиотека для Mock-тестирования.
* `.class` - получение описания типа какого-либо класса, используется, когда Java нужно проверить, принадлежит ли какой-либо объект какому-то классу.
* `stubbing` - процесс, когда мы явно прописываем реализацию какой-либо заглушки
* `verify` - подходит, когда нужно проверить, был ли вызван void-метод

## Словарик

* `before each` - перед каждым
* `after each` - после каждого
* `temp` - временный
* `exists` - существует (содержится)
* `nested` - внутренний
* `expected` - ожидаемый (тот результат, который мы ожидаем)
* `actual` - актуальный (тот результат, который нам пришел по факту)
* `replace underscores` - заменить нижние подчеркивания

### Общение с чатом GPT

```
Привет!

А должен ли специалист по автоматизированному тестрованию знать, что такое mock-тестирование?

ChatGPT
Привет!

Да, специалист по автоматизированному тестированию должен быть знаком с понятием mock-тестирования.
 Mock-тестирование (или мок-тестирование) - это методика тестирования, 
 когда создаются фиктивные (заглушки) компоненты или объекты, 
 которые имитируют поведение реальных компонентов в системе. 
 Это позволяет изолировать тестируемый компонент от зависимостей, 
 которые могут влиять на результаты тестирования.

С помощью mock-объектов можно симулировать различные сценарии и 
взаимодействия, которые могут быть сложно воссозданы в реальной 
среде тестирования. Это особенно полезно, когда какие-либо
зависимости компонента, такие как базы данных, внешние сервисы или компоненты 
других команд, не готовы или не стабильны на момент тестирования.

С использованием mock-тестирования можно проверить, как компонент
 взаимодействует с окружающей системой, как он обрабатывает данные и какие вызовы
он осуществляет, не запуская всю систему целиком. Это помогает выявить проблемы в изоляции 
и обработке данных, а также упрощает отладку и тестирование отдельных частей приложения.

Таким образом, знание о mock-тестировании будет полезным для 
специалиста по автоматизированному тестированию, чтобы эффективно 
тестировать компоненты в изоляции и обеспечивать надежную и стабильную работу всей системы.
```