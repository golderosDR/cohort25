![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_03/img/1.png)

## Слабая связь между компонентами

* Благодаря тому, что у нас классы ссылаются на интерфейсы, мы можем менять конфигурацию приложения в Main, подставляя разные реализации одних и тех же интерфейсов

* В реальных приложениях компонентов может быть достаточно много, например:
  * Слой сервисов для обычного пользователя и администратора
  * Различные виды валидаторов
  * Куча контроллеров на разные запросы
  * Разные репозитории и разные типы репозиториев\
* В приложениях, где таких компонентов много становится трудно самостоятельно создавать объекты и связывать их между собой (как в примере Main)

## Spring

* Реализует подход IoC/DI

### Основные понятия

* `Bean\Бин` - центральное понятие Spring. Бин - это просто объект какого-либо класса, который "управляется" Spring-ом (Spring management)
* Когда обычный объект называют "бином Spring"? Когда этот объект был создан с использованием Spring.
* Мы можем создать класс (как правило, его помечают аннотацией `@Configuration`) в котором мы опишем "бины".
* Каждый бин характеризуется своим "названием/id" и классом, на основе которого он создан.
* В случае, если мы создаем бин с помощью метода, например:

```
    @Bean
    public PasswordValidator passwordValidatorNotEmpty() {
        return new PasswordNotEmptyValidatorImpl();
    }
```

* То здесь id-бина - это название метода - `passwordValidatorNotEmpty`
* А класс/тип бина -  `PasswordValidator`
* Чтобы воспользоваться этим бином, необходимо его погрузить в `Spring Context`, а именно:

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

* После того, как мы погрузили его в Spring Context, мы можем его оттуда вытащить по id и типу:

```java
PasswordValidator passwordValidator = applicationContext.getBean("passwordValidatorRegex", PasswordValidator.class);
```

## Пройдем заново

1. В Main мы создавали экземпляры каждого класса и связывали их между собой.
2. В Main2 мы обратились к контейнеру Spring (Spring Context) и попросили у него бин с типом `UsersController`
3. Данный бин к нам пришел с зависимостью на `UsersService`,а тот, в свою очередь зависит от всех других бинов.
4. Чтобы бины были в контейнере, я создал класс `AppConfig` в котором перечислил все бины, которые мне нужны.
5. Подход, когда логика создания компонентов приложения и их связывания выносится в отдельный модуль - называется Inversion of Control (IoC).

* Бин - это просто объект, компонент приложения, экземпляр какого-либо класса, просто он находится внутри контейнера/контекста Spring.
* Как было сказано, у бина есть тип и название (id).
* Есть множество способов объявления бина, один из них - аннотация `@Bean`
* `@Bean` - аннотация, которой мы помечаем метод, результатом работы которого является какой-либо бин.

```
@Bean
public PasswordValidator passwordValidatorNotEmpty() {
    return new PasswordNotEmptyValidatorImpl();
}
```

* `passwordValidatorNotEmpty` - будущее название/id вашего бина типа `PasswordValidator`
* внутри метода описываем логику создания нашего бина, в конце обязательно `return`
* id-бина может быть абсолютно любым, главное - уникальным:

```
@Bean
public PasswordValidator xyz() {
    return new PasswordNotEmptyValidatorImpl();
}
```

* В метод, который помечен аннотацией `@Bean` можно подставить другие бины в параметрах метода.
* Название параметра должно соответствовать названию бина, если у вас несколько бинов одинакового типа. 
* Если бин по такому типу только один - на название параметра все равно.

## Итоги

* Положить бин в контейнер можно с помощью аннотации `@Bean`
* Получить бин из контейнера можно с помощью:
  * `applicationContext.getBean(ТипНужногоБина.class)`
  * `applicationContext.getBean(Id-нужного-бина, ТипНужногоБина.class)`